[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15300355&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:
Software engineering is the Branch of computer science that deals with the design , development , testing and maintainance of software applications. Or can be defined as the process of desining, developing , testing and maintaining software. It is a systematic and disciplined approach to software development that aims to create high-quality , reliable and maintainable software . 

What is software engineering, and how does it differ from traditional programming?
Software engineering simply defined as the process of designing , developing , testing and maintaining software . Software Software Engineering Process is a process that majorly involves computer science, information technology, and discrete mathematics whilist traditional programming mostly involve science,mathematics and imperical knowledge.  Software engineering mostly involves computers, programming , writing codes for building applications while traditional programming is mainly dealing with building of cars, machines , hardware ,buldings etc. In Software engineering pocesses the construction and development cost is low while in the traditional programming the cost of construction and developement is high . Software engineering moreoften follows the established standard and frameworks while the traditional programming may have a well established regulation and standard. Software engineering often inovles complex logic and algorithms while the traditional programming may have more complex physical properties to deal with. In Softwaare engineering maintainance and updates are necessary to keep software relevant  while in traditional programming maintainance is typically scheduled or reactive . Again in Software engineering prototyping is common and help to refine  requirements while in Traditional programming prototyping is less common due to cost and time. Testing is an integral part of the develpment process in software engineering while in Traditional programming testing is occur mainly after product completion .Design requirements may change throughout the development process in Software engineering while in Tradiional programming Design Requirements are typically well-defined upfront. Software engineering majorly emphasizes quality while taditional programming  majorly emphasizes mass production.  In software engineering the developement effort goes into building new designs and features while in the traditional programming more development  effort are required to change the old designs. Moreover in software engineeering Agile methedologies are commonly used in software development while in traditional programming may use more traditional project management approaches.

Software Development Life Cycle (SDLC):
 The Software Development Life Cycle is a basis or framework for structuring, planning,and executing tasks involved with developing an information system .The SDLC includes distinct phases designed to give software engineers a clearly defined goal for how to work.t aims to aid developers and other project staff to create a system that meets all technical and user requirements as well as exceeds customer expectations.hese phases all revolve around a central theme of quality assurance. The major priority of the project team is to provide quality software to the users and client.

Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.
The Initiation phases is the first phase which identifies a problem to be solved through   software engineering, Planning phase is the second phase whare Most of the documents needed during the other phases of the SDLC are made here. These may include an Acquisition Plan, Concept of Operations, and Project Management Plan,but there are many more that may be relevant to different projects. A summary is usually presented to stakeholders at this point, and a detailed plan is presented and reviewed. The Requirements Analysis phase starts after the documents prepared in the previous
phases are reviewed and approved. Any document stating user needs in the system will serve as the basis for document created in this phase that illustrate user requirements and system requirements. Details such as system inputs, interfaces, and processes are described here. Typically, a Software Requirement Specification document or Functional Requirements document is created during this phase which includes information about how to meet user requirements. This may address issues with users with disabilities such as color-blindness, hearing loss, or cognitive disabilities, or mobility impairments.A Test Plan may also be created during this phase and may include details on unit test, integration test, and/or system tests. The portion of documentation is often created by the development team with the help of a Quality Assurance (QA) team whose purpose is to make sure different types of users can easily use the system. In the Design phase, detailed requirements are to be turned into detailed specifications that engineers will use during the Development phase. These specifications should address how functional, physical, interface, and data requirements are to be met in the system. This is usually done iteratively through the entire life cycle process. Designs may include database designs and user interface designs.Development phase purposely is to convert designs from the Design phase into a functional system. This not only includes the software that should be written, but also the infrastructure that should be set in place. These infrastructures may include hardware,software, and communication systems that are required for the functionality of the overall system. Besides the code that is written, some deliverables expected as a result of this
phase include a Contingency Plan that directs the client what to do in case of emergency; a Software Development document which illustrates test cases and results, how the components work, and approvals; the test files and data; and an Integration Document
which illustrates how the software and hardware components work together.The Integration and Testing phase aims to determine if the requirements specified in the specifications document are met.Three different types of testing are ideal to include in this phase: integration testing of subsystems, security testing, user testing or acceptance testing, and unit testing. Each of these types of tests setve a different purpose and help all stakeholders determine flaws in the system prior to deployment. Unit testing, which tests
small portions of code and is traditionally done during the development phase. Several analysis reports may be produced from these tests and should presented to stakeholders before moving on to the implementation phase. During this meeting, details on how
implementation should take place are imperative to address.Implementation phase ,During this phase, the system is deployed to the production environment. It is important to inform users of the potential system changes prior to deployment and to train any
professionals on the new system if required. A post-implementation review is commonly completed to make sure all requirements are met and the system is functioning in production as expected. If everything is in order, a contract between the development team and the client project manager is signed, stating that the system has been completed and delivered. More than half the cost of the development life cycle is due to the Operations and Maintenance phase. This phase may include identifying system operations, maintaining data, identifying problems, and revising documentation that received additional analysis (e.g. security audit/analysis). A User-Satisfaction report may be developed during this phase to identify and potential user end problems to address in future development.This phase is done only when a system has become obsolete or been replaced by another. Prior to shutting down the system, it is necessary to make sure all documentation and resources are in order. A plan for shutdown should be written and followed strictly, making sure to backup all resources and data from the system. It is also recommended that a security and contingency plan be made and stored with the system in case it has to be setup again. Lemke, Gillian, "The Software Development Life Cycle and Its Application" (2018). Senior Honors Theses. 589.
https://commons.emich.edu/honors/589
Agile vs. Waterfall Models:

Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
Agile model is more flexible as it takes these processes in repeating cycles. Agile enables the software team and end users to “collectively learn to plan better, work better and adjust more quickly, and outcomes become far more predictable as the way the team works becomes more predictable,” Chowning says. “On time and on budget are much easier to judge with the finger on the pulse of expectations of both the users and the developers.” while waterfall model relies on thorough front planning.The waterfall method of gathering all the requirements, designing the entire software capability to meet all the requirements, building all the needed capabilities and reviewing and obtaining buy-in from end users is rarely used today, Chowning says. “This older method, by the way, is where on-time, on-budget challenges were the most onerous, because of the guessing game created when the software team had to estimate large bodies of work and assume some level of acceptance or rework by end users,” she says. But again agile is for dynamic, evolving projects while waterfall works best for well defined, unchanging projects.
Requirements Engineering:

What is requirements engineering? Describe the process and its importance in the software development lifecycle.
 Requirements engineering is part of engineering and focuses on the actual goals, functions, and constraints of a systemIt is the process of eliciting, analyzing, specifying, validating, and maintaining the requirements of a system . It entails identifying stakeholders’ needs; recognizing the context of the requirements; representing those requirements in an easily understandable manner; and negotiating, validating, documenting, and managing those requirements. Failing to identify correct needs leads to flaws in specifications and the other components of a system.Inadequately defined requirements can cause many difficult problems, which have an impact on different direct and indirect stakeholders of software systems. Requirements engineering offers suitable instruments designed for recognizing and examining customers’ real needs, reviewing viability, stipulating the solution explicitly, confirming the requirements, managing the requirements, and settling on a practical solution as they are transformed into an operational system.Requirements engineering encompasses many sub-processes. The major five sub-processes are requirements elicitation, requirements analysis and negotiation, requirements specification, requirements validation, and requirements management.
Software Design Principles:

Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?
Modularity in software design refers to the design approach that emphasises the separation of concerns, where a complex software system is divided into smaller, loosely coupled modules Each module performs a specific function or handles a particular feature, and they interact through well-defined interfaces. This approach promotes a clear division of labour, allowing developers to focus on individual modules without being overwhelmed by the entire system’s complexity.Modularity in software engineering offers numerous benefits, ranging from improved readability and maintainability to facilitating parallel development and easing the debugging and testing processes.Enhanced readability and maintainability By structuring a software system into smaller, cohesive modules, the code becomes easier to understand and navigate Each module encapsulates a specific functionality or feature, and its purpose is well-defined.This improves the overall readability of the code, enabling developers to grasp its logic and architecture quickly.Additionally, when changes or updates are required, developers can focus on individual modules without the need to understand the entire system, making maintenance more manageable.Facilitating parallel development,Modularity in software engineering enables parallel development, allowing multiple developers or teams to work on different modules simultaneously.Since modules are designed to be loosely coupled, changes made to one module are unlikely to impact others significantly.This reduces the need for coordination and minimises conflicts that may arise when multiple developers are working on the same codebase. As a result, productivity increases, and development timelines can be significantly shortened.Easing the debugging and testing process
The modular structure of software systems facilitates the debugging and testing processes. When a bug or issue arises, developers can isolate the problematic module and focus solely on that part of the code. This narrow scope makes it easier to identify the root cause and apply targeted fixes. Additionally, modular code is easier to test since each module can be tested independently, verifying its inputs, outputs, and expected behaviour. This increases the reliability of the software and reduces the time spent on debugging and testing.https://www.institutedata.com/blog/modularity-in-software-engineering/
Testing in Software Engineering:

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
Testing phase aims to determine if the requirements specified in the
specifications document are met. Three different types of testing are ideal to include in this phase: integration testing of subsystems, security testing, user testing or acceptance
testing, and unit testing. Each of these types of tests serves a different purpose and help all stakeholders determine flaws in the system prior to deployment. Unit testing, which tests small portions of code and is traditionally done during the development phase. Several analysis reports may be produced from these tests and should presented to stakeholders before moving on to the implementation phase. During this meeting, details on how implementation should take place are imperative to address.Lemke, Gillian, "The Software Development Life Cycle and Its Application" (2018). Senior Honors Theses. 589.
https://commons.emich.edu/honors/589
Version Control Systems:

What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.
Version control lets us track file changes and access specific versions when needed. It helps developers collaborate and is essential to any successful software project. From simple file backups in the 1970s to centralized CVS and distributed Git, version control systems have evolved dramatically. This evolution has improved coding efficiency and collaboration, shaping software development. Understand version control fundamentals and compare version control systems.Git is a distributed version control system. It’s popular due to its speed, data integrity, and support for distributed workflows. Platforms like GitHub, GitLab, and Bitbucket have increased its popularity.Subversion, or SVN, is a centralized version control system. It’s known for its simplicity and linear history model. Despite being older, it’s still used in many projects.Mercurial is a distributed version control system like Git. It emphasizes simplicity and ease of use, making it a good choice for smaller teams or projects.Types of Version Control Systems (VCS) Local VCS: Stores changes in local files. Risky due to a single point of failure. Centralized VCS (e.g., SVN): A single, central server hosts the full version history. Fast and straightforward but vulnerable to server failure. Distributed VCS (e.g., Git, Mercurial): Every user has a complete copy of the repository. Robust against failures, supports flexible workflows.Benefits of Using Version Control Collaboration : Version control systems are the linchpin of a collaborative development environment. They allow multiple developers to work on the same project simultaneously, each making their changes in a controlled and isolated manner. This prevents overwriting and conflicting changes, ensuring that each developer’s work is preserved and integrated correctly. Track Changes : A version control system keeps a comprehensive history of all changes made to the project, including who made the changes and why. This audit trail is invaluable for understanding the evolution of a project, debugging issues, and holding developers accountable for their changes. It provides a clear picture of the project’s progression and the decisions that shaped it. Experimentation: One of the most powerful features of version control systems is the ability to create separate branches for experimentation. Developers can diverge from the main line of development and explore new ideas without fear of destabilizing the main project. If the experiment is successful, it can be merged back into the main project. If not, it can be discarded without any adverse impact. Rollback : Despite best efforts, sometimes new features can introduce bugs or not meet expectations. In such cases, version control systems provide the ability to revert to previous versions. This rollback feature ensures that you can quickly recover from mistakes or unwanted changes, maintaining the stability and integrity of your projectSelecting the right version control system is a crucial part of the planning stage because the version control system is difficult to change after the project has developed.https://refine.dev/blog/version-control/#rollback
Software Project Management:

Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?
Project managers play a vital role in efficient project execution, meeting client expectations, budget adherence, and delivering quality software. Below is a list of a project manager’s key responsibilities in a software development environment:•	Planning & Scope: In the early stages of a software project, the project manager is the architect defining its essence, objectives, proper scope, and deliverables. They create a detailed project plan with milestones, allocate resources efficiently, and maintain budgetary discipline, ensuring the project’s success and approval with all stakeholders.
•	Requirements & Analysis: Project managers facilitate vital stakeholder collaboration, comprehensively refining project requirements and definition. They work with the project team to assess the overall feasibility, identify potential pitfalls, and minimize risks. They also detail precise and actionable requirements for meeting the desired outcomes.
•	Resource Management: A primary function of a project manager is to orchestrate the use of resources with precision. They assemble and guide project teams, carefully choosing members with skills matching the project’s needs. Beyond initial assembly, they optimize resource allocation, recognizing that it’s about strategic distribution for judicious investment of assets and time. This multifaceted role ensures harmonious functioning, resulting in precision and excellence throughout the project’s performance.
•	Risk Management: A project manager’s proactive approach is essential in navigating potential risks. Beyond risk identification, they foster a continuous risk-awareness culture within the team. Their foresight ensures swift responses to challenges, safeguarding the project’s path to successful completion.
•	Monitoring & Control: Project managers oversee project progress and key performance indicators, ensuring each phase runs smoothly. More than just observers, they proactively guide projects to success, quickly addressing deviations and realigning the project’s direction when this occurs. Acting as the project’s compass, they ensure it navigates challenges and remains on the path to success.
•	Quality Assurance: Effective project managers are champions of software quality. They set rigorous standards that serve as blueprints for excellence, ensuring each team member understands and adheres to these benchmarks. Regular quality checks, inspections, and tests are conducted to maintain these standards.
•	Stakeholder Communication: Project managers assume the role of the central point of contact, connecting technical teams with stakeholders and resources and acting as the conduits through which information flows. They ensure that all stakeholders, whether technical experts or project sponsors, are not only privy to project progress, but also attuned to changes and milestones. It’s their responsibility to nurture a collaborative environment among team members and make sure that everybody is working towards the same goal.
•	Documentation & Reporting: Project managers are the stewards of project documentation, maintaining records such as project plans, status reports, and meeting minutes. These documents serve as the project’s archive, detailing its progress and capturing any changes or key decisions. Beyond record-keeping, project managers create reports for stakeholders to keep them informed about the project’s status and foster transparency.
•	Change Management: Project managers orchestrate change requests and evaluate their impact on the project’s goals, timelines, and budgets. Their role involves not only assessing changes, but also advocating for necessary adjustments and securing approvals. This ensures that changes are strategically aligned with the project’s direction and that the project adapts effectively, keeping it on track to successful completion.
•	Closure & Evaluation: Project managers play a crucial role in project success by overseeing technical completion and facilitating a smooth transition from development to deployment or maintenance. They conduct post-project evaluations to extract insights, enabling teams to improve. Archiving project documents ensures compliance and knowledge retention, making project managers essential for efficient project execution and organizational growth.
•	Client Satisfaction: Project managers actively engage with clients to gather feedback and address any concerns that may arise. They will additionally provide post-project support to ensure the client’s continued satisfaction throughout the project life cycle.
•	Continuous Improvement: Staying abreast of industry best practices, emerging technologies and project management tools, and evolving project management methodologies is a hallmark of a skilled project manager. They will consistently design and implement process enhancements to help elevate the efficiency and effectiveness of project management practices. Alongside the role of the Software engineering hereis the challenges associated with his role to mention are derivering on time and on budget . Number of things can happen to cause delay and drives up cost .https://www.developer.com/project-management/role-of-a-project-manager-in-software-development/

Software Maintenance:

Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
Software maintenance is the process of changing, modifying, and updating software to keep up with customer needs. Software maintenance is done after the product has launched for several reasons including improving the software overall, correcting issues or bugs, to boost performance, and more.
Ethical Considerations in Software Engineering:

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?
Software engineers should have sound ethical standards on professional and personal aspects. The work of software engineers has a direct impact on the well-being of society. There is nothing outside the people; their work is intimately associated with the
welfare, safety, and health of human beings. Unlike medical professionals and lawyers, who primarily focus on their clients, the primary interest and obligation of software engineering
professionals is the “public interest”. He/she must have concerns about employers, clients, professionals, and other parties [34].
In the field of software engineering, the software code of ethics requires high consid-eration in research. Considering the ethical concerns of the software development projects will increase the public’s trust and the professional image of the software artifacts,
as well as interior and exterior communication among different stakeholders and their sat-isfaction. With these principles in mind, there should be an explicit guideline/framework that entails which things should be considered and integrated regarding ethical concerns in each phase of the software development project. Furthermore, expressing ethical concerns in the software development project will help as a tool for software developers to soundly recognize and uphold the code of ethics in their profession . There are many codes of ethics in the software engineering field. However, in practice, ethical concerns are not explicitly considered during software development . The software engineering code of ethics (SWECODE) [9 ] is one of the areas of software engineering that needs increased research consideration. It can take a significant part of the practice and has an enormous impact on the daily lives of human beings. The level of harm on human beings because of defective software equipment greatly depends on the aptitudes of software engineers to pursue high performance in software engineering. The research on practices of the software engineering code of ethics during the software
development process is understudied . Currently, the use of software is ubiquitous. It is possible to find the implementation
of software in virtually all day-to-day activities. Kids’ electronic toys, smartphones, televi- sions, refrigerators, cars’ onboard computer systems are just a few examples of software applications. Software plays a crucial function in offering business information solutions for enterprise resource planning, enabling, organizing, and protecting the activities of
large, medium, and small-sized organizations. Software engineers, who are responsible for the development of software systems, have an important perspective role to put in place good practices. This means that software engineers should be highly committed to making
software artifacts usable and beneficial for the stakeholders and society at large . Software developers must be responsible for implementing technical mechanisms, which shape the corresponding organization’s ethical dimensions . Substantial software is being used daily and the situation becomes critical when it affects users negatively. For the duration of software SDLC, developers face critical ethical decisions to guarantee a minimal impact on users and stakeholders. There are numerous reasons why it is decisive to
add ethical practices and considerations in decisions regarding any software development project . Software developers should carefully ponder the incorporation of technical and ethical dimensions in the decisions of software development projects, seeking to protect
the software, while preventing prospective harm to others.
Software developers are responsible for their profession and the public at large within the scope of their profession. They should have the willingness to hold to their professional code of ethics as part of their contributions to society by developing high-quality and valuable software . Software engineers are accountable for both the result of their software artifacts and the faults of such works. They have the duty to identify and understand the vulnerability of such hazardous requirements, making sure that they are securely operated. Clients cannot recognize the impact of those requirements. The software developer/engineer is responsi-
ble and accountable for caring for those defective software requirements and producing quality software . During software development decisions, clearly considering ethical
concerns is very useful to integrate both technical and ethical issues of the software artifacts. As stated above, software engineers are accountable for their profession and society at
large . Moreover, they have the responsibility to do the right things for both clients and society. As a result, a careful investigation of ethical concerns in software engineering
is necessary.Citation: Biable, S.E.; Garcia, N.M.;
Midekso, D.; Pombo, N. Ethical
Issues in Software Requirements
Engineering. Software 2022, 1, 31–52.
https://doi.org/10.3390/
software1010003
Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
